package gg.archipelago.aprandomizer.common.commands;import java.util.HashMap;import java.util.Map;import java.util.concurrent.CompletableFuture;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import com.mojang.brigadier.CommandDispatcher;import com.mojang.brigadier.arguments.StringArgumentType;import com.mojang.brigadier.context.CommandContext;import com.mojang.brigadier.exceptions.CommandSyntaxException;import com.mojang.brigadier.suggestion.SuggestionProvider;import com.mojang.brigadier.suggestion.Suggestions;import com.mojang.brigadier.suggestion.SuggestionsBuilder;import gg.archipelago.aprandomizer.APRandomizer;import gg.archipelago.aprandomizer.capability.data.WorldData;import gg.archipelago.aprandomizer.events.ReceiveItem;import net.minecraft.commands.CommandBuildContext;import net.minecraft.commands.CommandSourceStack;import net.minecraft.commands.Commands;import net.minecraft.commands.SharedSuggestionProvider;import net.minecraft.commands.synchronization.SuggestionProviders;import net.minecraft.network.chat.Component;import net.minecraft.resources.ResourceLocation;import net.minecraftforge.event.RegisterCommandsEvent;import net.minecraftforge.eventbus.api.SubscribeEvent;import net.minecraftforge.fml.common.Mod;@Mod.EventBusSubscriberpublic class InformCommand {	// Directly reference a log4j logger.	private static final Logger LOGGER = LogManager.getLogger();    static Map<String, Integer> suggestions = new HashMap<String, Integer>() {{						put("None", 0);						put("Title", 1);						put("Sidebar", 2);						put("Both", 3);											}};	public static SuggestionProvider<CommandSourceStack> INFOMODE = SuggestionProviders.register(			ResourceLocation.fromNamespaceAndPath(APRandomizer.MODID, "info_mode"),			new SuggestionProvider<SharedSuggestionProvider>() {								@Override				public CompletableFuture<Suggestions> getSuggestions(CommandContext<SharedSuggestionProvider> context,						SuggestionsBuilder builder) throws CommandSyntaxException {														return SharedSuggestionProvider.suggest(suggestions.keySet().stream(), builder) ;					/*									builder.suggest(WorldData.NONE, Component.literal("None"))							.suggest(WorldData.TITLE, Component.literal("Title"))							.suggest(WorldData.SIDEBAR, Component.literal("Sidebar"))							.suggest(WorldData.BOTH, Component.literal("Both")).buildFuture();					*/				}			});	// build our command structure and submit it	public static void Register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext pContext) {		dispatcher.register(Commands.literal("inform") // base slash command is "inform"				.then(Commands.argument("mode",  StringArgumentType.string())						.suggests(INFOMODE)				.executes(context -> Inform(context))));	}	private static int Inform(CommandContext<CommandSourceStack> commandSourceCommandContext) {		if (!APRandomizer.getAP().isConnected()) {			commandSourceCommandContext.getSource()					.sendFailure(Component.literal("Please connect to the Archipelago server before starting."));			return 1;		}		String informMode = StringArgumentType.getString(commandSourceCommandContext, "mode");		LOGGER.info("We got a value of: " + informMode);		int parse = suggestions.get(informMode);		APRandomizer.worldData.setInformMode(parse);		ReceiveItem.SetDisplay((parse & 2) == WorldData.SIDEBAR);		commandSourceCommandContext.getSource().sendSuccess(() -> Component.literal("Successfully changed info mode to " + informMode), true);		return 1;	}	// wait for register commands event then register ourself as a command.	@SubscribeEvent	static void onRegisterCommandsEvent(RegisterCommandsEvent event) {		InformCommand.Register(event.getDispatcher(), event.getBuildContext());	}}